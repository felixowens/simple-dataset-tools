package main

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
)

type CaptioningService interface {
	GenerateCaption(imageBase64 string, systemPrompt string) (string, error)
}

type GeminiService struct {
	APIKey string
}

type GeminiRequest struct {
	Contents []GeminiContent `json:"contents"`
}

type GeminiContent struct {
	Parts []GeminiPart `json:"parts"`
}

type GeminiPart struct {
	Text       string            `json:"text,omitempty"`
	InlineData *GeminiInlineData `json:"inlineData,omitempty"`
}

type GeminiInlineData struct {
	MimeType string `json:"mimeType"`
	Data     string `json:"data"`
}

type GeminiResponse struct {
	Candidates []GeminiCandidate `json:"candidates"`
	Error      *GeminiError      `json:"error,omitempty"`
}

type GeminiCandidate struct {
	Content GeminiContent `json:"content"`
}

type GeminiError struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

func NewGeminiService(apiKey string) *GeminiService {
	return &GeminiService{APIKey: apiKey}
}

func (g *GeminiService) GenerateCaption(imageBase64 string, systemPrompt string) (string, error) {
	if g.APIKey == "" {
		return "", fmt.Errorf("Gemini API key not configured")
	}

	// Default system prompt if none provided
	if systemPrompt == "" {
		systemPrompt = "Describe this image in detail for training a diffusion model. Focus on the visual elements, composition, style, and any notable features."
	}

	// Determine MIME type based on base64 data
	mimeType := "image/jpeg"
	if len(imageBase64) > 0 {
		// Simple detection based on base64 header
		if imageBase64[:4] == "iVBO" { // PNG signature in base64
			mimeType = "image/png"
		} else if imageBase64[:4] == "UklG" { // WebP signature in base64
			mimeType = "image/webp"
		}
	}

	request := GeminiRequest{
		Contents: []GeminiContent{
			{
				Parts: []GeminiPart{
					{
						Text: systemPrompt,
					},
					{
						InlineData: &GeminiInlineData{
							MimeType: mimeType,
							Data:     imageBase64,
						},
					},
				},
			},
		},
	}

	requestBody, err := json.Marshal(request)
	if err != nil {
		return "", fmt.Errorf("failed to marshal request: %v", err)
	}

	// Gemini Vision API endpoint
	url := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=%s", g.APIKey)

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(requestBody))
	if err != nil {
		return "", fmt.Errorf("failed to call Gemini API: %v", err)
	}
	defer resp.Body.Close()

	responseBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response: %v", err)
	}

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("Gemini API error (status %d): %s", resp.StatusCode, string(responseBody))
	}

	var geminiResponse GeminiResponse
	if err := json.Unmarshal(responseBody, &geminiResponse); err != nil {
		return "", fmt.Errorf("failed to unmarshal response: %v", err)
	}

	if geminiResponse.Error != nil {
		return "", fmt.Errorf("Gemini API error: %s", geminiResponse.Error.Message)
	}

	if len(geminiResponse.Candidates) == 0 || len(geminiResponse.Candidates[0].Content.Parts) == 0 {
		return "", fmt.Errorf("no caption generated by Gemini API")
	}

	return geminiResponse.Candidates[0].Content.Parts[0].Text, nil
}

func CreateCaptioningService(config *CaptionAPIConfig) (CaptioningService, error) {
	if config == nil {
		return nil, fmt.Errorf("caption API configuration is required")
	}

	switch config.Provider {
	case "gemini":
		return NewGeminiService(config.APIKey), nil
	default:
		return nil, fmt.Errorf("unsupported caption API provider: %s", config.Provider)
	}
}

func ImageToBase64(imagePath string) (string, error) {
	imageFile, err := os.Open(imagePath)
	if err != nil {
		return "", fmt.Errorf("failed to open image file: %v", err)
	}
	defer imageFile.Close()

	imageData, err := io.ReadAll(imageFile)
	if err != nil {
		return "", fmt.Errorf("failed to read image file: %v", err)
	}

	return base64.StdEncoding.EncodeToString(imageData), nil
}

func GenerateCaptionForTask(projectID, taskID string) (*CaptionResponse, error) {
	// Get the caption task
	task, err := getCaptionTask(taskID)
	if err != nil {
		return &CaptionResponse{Error: fmt.Sprintf("Failed to get caption task: %v", err)}, nil
	}
	if task == nil {
		return &CaptionResponse{Error: "Caption task not found"}, nil
	}

	// Get the project to access API configuration
	project, err := getProject(projectID)
	if err != nil {
		return &CaptionResponse{Error: fmt.Sprintf("Failed to get project: %v", err)}, nil
	}
	if project == nil {
		return &CaptionResponse{Error: "Project not found"}, nil
	}

	// Check if caption API is configured
	if project.CaptionAPI == nil {
		return &CaptionResponse{Error: "Caption API not configured for this project"}, nil
	}

	// Parse the caption API configuration
	var apiConfig CaptionAPIConfig
	if err := json.Unmarshal([]byte(*project.CaptionAPI), &apiConfig); err != nil {
		return &CaptionResponse{Error: fmt.Sprintf("Invalid caption API configuration: %v", err)}, nil
	}

	// Get the image
	image, err := getImage(task.ImageID)
	if err != nil {
		return &CaptionResponse{Error: fmt.Sprintf("Failed to get image: %v", err)}, nil
	}
	if image == nil {
		return &CaptionResponse{Error: "Image not found"}, nil
	}

	// Convert image to base64
	imagePath := filepath.Join("data", "projects", projectID, image.Path)
	imageBase64, err := ImageToBase64(imagePath)
	if err != nil {
		return &CaptionResponse{Error: fmt.Sprintf("Failed to encode image: %v", err)}, nil
	}

	// Create captioning service
	captioningService, err := CreateCaptioningService(&apiConfig)
	if err != nil {
		return &CaptionResponse{Error: fmt.Sprintf("Failed to create captioning service: %v", err)}, nil
	}

	// Use system prompt from project or default
	systemPrompt := "Describe this image in detail for training a diffusion model. Focus on the visual elements, composition, style, and any notable features."
	if project.SystemPrompt != nil && *project.SystemPrompt != "" {
		systemPrompt = *project.SystemPrompt
	}

	// Generate caption
	caption, err := captioningService.GenerateCaption(imageBase64, systemPrompt)
	if err != nil {
		logger.Error("Failed to generate caption", "error", err)
		return &CaptionResponse{Error: fmt.Sprintf("Failed to generate caption: %v", err)}, nil
	}

	return &CaptionResponse{Caption: caption}, nil
}
